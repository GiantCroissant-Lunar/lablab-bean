# Proxy Service Source Generator - Usage Guide

**Version**: 1.0.0
**Last Updated**: 2025-10-22

## Overview

The Proxy Service Source Generator automatically creates proxy service implementations for interfaces, eliminating manual delegation boilerplate. Simply mark a partial class with `[RealizeService]` and the generator creates all interface method/property/event implementations that delegate to `IRegistry`.

## Quick Start

### 1. Basic Proxy Service

**Step 1**: Define your service interface

```csharp
public interface IGameService
{
    void StartGame();
    string GetPlayerName();
    int GetScore();
}
```

**Step 2**: Create a partial class with `[RealizeService]` attribute

```csharp
using LablabBean.Plugins.Contracts.Attributes;

[RealizeService(typeof(IGameService))]
public partial class GameServiceProxy
{
    private readonly IRegistry _registry;

    public GameServiceProxy(IRegistry registry)
    {
        _registry = registry;
    }
}
```

**Step 3**: Build your project

The generator automatically creates:

```csharp
// <auto-generated />
// Generated by ProxyServiceGenerator at 2025-10-22 07:45:00 UTC

#nullable enable

namespace YourNamespace
{
    partial class GameServiceProxy : IGameService
    {
        public void StartGame()
        {
            _registry.Get<IGameService>().StartGame();
        }

        public string GetPlayerName()
        {
            return _registry.Get<IGameService>().GetPlayerName();
        }

        public int GetScore()
        {
            return _registry.Get<IGameService>().GetScore();
        }
    }
}
```

**Step 4**: Use your proxy

```csharp
var registry = new Registry();
registry.Register<IGameService>(new GameServiceImpl());

var proxy = new GameServiceProxy(registry);
proxy.StartGame();
var name = proxy.GetPlayerName();
```

## Examples

### Example 1: Basic Proxy Service (5 Methods)

```csharp
/// <summary>
/// Service for managing player data.
/// </summary>
public interface IPlayerService
{
    /// <summary>
    /// Gets the player's current level.
    /// </summary>
    int GetLevel();

    /// <summary>
    /// Sets the player's level.
    /// </summary>
    void SetLevel(int level);

    /// <summary>
    /// Adds experience points to the player.
    /// </summary>
    void AddExperience(int amount);

    /// <summary>
    /// Checks if the player can level up.
    /// </summary>
    bool CanLevelUp();

    /// <summary>
    /// Resets the player's progress.
    /// </summary>
    void ResetProgress();
}

[RealizeService(typeof(IPlayerService))]
public partial class PlayerServiceProxy
{
    private readonly IRegistry _registry;

    public PlayerServiceProxy(IRegistry registry)
    {
        _registry = registry;
    }
}
```

### Example 2: Proxy with Properties and Events

```csharp
public interface IInventoryService
{
    // Properties
    int ItemCount { get; }
    int MaxCapacity { get; set; }
    bool IsFull { get; }

    // Events
    event EventHandler<ItemAddedEventArgs>? ItemAdded;
    event EventHandler? InventoryCleared;

    // Methods
    void AddItem(string itemId);
    void RemoveItem(string itemId);
    void Clear();
}

[RealizeService(typeof(IInventoryService))]
public partial class InventoryServiceProxy
{
    private readonly IRegistry _registry;

    public InventoryServiceProxy(IRegistry registry)
    {
        _registry = registry;
    }
}

// Generated code includes:
// - Property getters/setters
// - Event add/remove accessors
// - All method implementations
```

### Example 3: Proxy with Generic Methods

```csharp
public interface IDataService
{
    // Generic method
    T GetData<T>(string key) where T : class;

    // Multiple type parameters
    TResult Transform<TInput, TResult>(TInput input);

    // Generic with constraints
    T CreateInstance<T>() where T : class, new();

    // Async generic
    Task<T> LoadAsync<T>(string path) where T : class;
}

[RealizeService(typeof(IDataService))]
public partial class DataServiceProxy
{
    private readonly IRegistry _registry;

    public DataServiceProxy(IRegistry registry)
    {
        _registry = registry;
    }
}

// Usage:
var proxy = new DataServiceProxy(registry);
var config = proxy.GetData<GameConfig>("settings");
var result = await proxy.LoadAsync<PlayerData>("player.json");
```

### Example 4: Advanced Features

```csharp
public interface IAdvancedService
{
    // Ref/out parameters
    void ModifyValue(ref int value);
    bool TryGetValue(string key, out string value);

    // In parameters
    void ProcessData(in ReadOnlySpan<byte> data);

    // Params arrays
    string Concatenate(params string[] values);

    // Default parameters
    void Configure(int timeout = 30, string mode = "default");

    // Nullable types
    string? GetOptionalValue();
    void SetOptionalValue(string? value);

    // Async methods
    Task InitializeAsync();
    Task<int> CalculateAsync();
}

[RealizeService(typeof(IAdvancedService))]
public partial class AdvancedServiceProxy
{
    private readonly IRegistry _registry;

    public AdvancedServiceProxy(IRegistry registry)
    {
        _registry = registry;
    }
}
```

## Selection Strategies

Control how services are retrieved from the registry using `[SelectionStrategy]`:

### SelectionMode.One (Exactly One)

```csharp
[RealizeService(typeof(IGameService))]
[SelectionStrategy(SelectionMode.One)]
public partial class GameServiceProxy
{
    private readonly IRegistry _registry;
    public GameServiceProxy(IRegistry registry) => _registry = registry;
}

// Generated: _registry.Get<IGameService>(SelectionMode.One)
// Throws if zero or multiple implementations exist
```

### SelectionMode.HighestPriority (Default)

```csharp
[RealizeService(typeof(IGameService))]
[SelectionStrategy(SelectionMode.HighestPriority)]
public partial class GameServiceProxy
{
    private readonly IRegistry _registry;
    public GameServiceProxy(IRegistry registry) => _registry = registry;
}

// Generated: _registry.Get<IGameService>(SelectionMode.HighestPriority)
// Returns implementation with highest priority
```

### SelectionMode.All (First from All)

```csharp
[RealizeService(typeof(IGameService))]
[SelectionStrategy(SelectionMode.All)]
public partial class GameServiceProxy
{
    private readonly IRegistry _registry;
    public GameServiceProxy(IRegistry registry) => _registry = registry;
}

// Generated: _registry.GetAll<IGameService>().First()
// Gets first from all implementations
```

### No Strategy (Default Behavior)

```csharp
[RealizeService(typeof(IGameService))]
public partial class GameServiceProxy
{
    private readonly IRegistry _registry;
    public GameServiceProxy(IRegistry registry) => _registry = registry;
}

// Generated: _registry.Get<IGameService>()
// Uses default registry behavior (HighestPriority)
```

## Common Errors and Solutions

### Error: PROXY001 - Service type must be an interface

**Problem**:

```csharp
[RealizeService(typeof(MyClass))]  // MyClass is not an interface
public partial class MyProxy { }
```

**Error Message**:

```
The type 'MyClass' specified in [RealizeService] must be an interface
```

**Solution**:

```csharp
[RealizeService(typeof(IMyService))]  // Use interface type
public partial class MyProxy
{
    private readonly IRegistry _registry;
    public MyProxy(IRegistry registry) => _registry = registry;
}
```

### Error: PROXY002 - Missing IRegistry field

**Problem**:

```csharp
[RealizeService(typeof(IMyService))]
public partial class MyProxy
{
    // Missing _registry field!
}
```

**Error Message**:

```
The class 'MyProxy' must have a field 'private readonly IRegistry _registry;'
```

**Solution**:

```csharp
[RealizeService(typeof(IMyService))]
public partial class MyProxy
{
    private readonly IRegistry _registry;  // Add this field

    public MyProxy(IRegistry registry)
    {
        _registry = registry;
    }
}
```

### Error: Class is not partial

**Problem**:

```csharp
[RealizeService(typeof(IMyService))]
public class MyProxy  // Missing 'partial' keyword
{
    private readonly IRegistry _registry;
}
```

**Solution**:

```csharp
[RealizeService(typeof(IMyService))]
public partial class MyProxy  // Add 'partial' keyword
{
    private readonly IRegistry _registry;
    public MyProxy(IRegistry registry) => _registry = registry;
}
```

## Troubleshooting

### Generated code not appearing

**Check**:

1. Is the class marked as `partial`?
2. Does the class have the `[RealizeService]` attribute?
3. Does the class have a `private readonly IRegistry _registry;` field?
4. Is the target type an interface?
5. Try rebuilding the project (Clean + Build)

### Compilation errors in generated code

**Check**:

1. Is the interface accessible from the proxy class?
2. Are all interface dependencies available?
3. Is the `IRegistry` type available?
4. Check for namespace conflicts

### Generator not running

**Check**:

1. Is `LablabBean.SourceGenerators.Proxy` referenced in your project?
2. Is the generator configured correctly in the `.csproj` file?
3. Try restarting Visual Studio / your IDE
4. Check the build output for generator errors

### Performance issues

**Tips**:

- The generator uses incremental generation (fast rebuilds)
- Only changed files trigger regeneration
- Build time impact should be <1 second
- If slow, check for other build issues

## Best Practices

### 1. One Proxy Per Interface

```csharp
// Good: One proxy for one interface
[RealizeService(typeof(IGameService))]
public partial class GameServiceProxy { }

// Avoid: Multiple proxies for same interface (unless needed)
```

### 2. Use Descriptive Names

```csharp
// Good: Clear, descriptive names
[RealizeService(typeof(IPlayerService))]
public partial class PlayerServiceProxy { }

// Avoid: Generic names
[RealizeService(typeof(IPlayerService))]
public partial class Proxy1 { }
```

### 3. Document Your Interfaces

```csharp
// Good: XML documentation is copied to generated code
/// <summary>
/// Service for managing game state.
/// </summary>
public interface IGameService
{
    /// <summary>
    /// Starts a new game session.
    /// </summary>
    void StartGame();
}
```

### 4. Use Selection Strategies Appropriately

```csharp
// Use SelectionMode.One when exactly one implementation is required
[SelectionStrategy(SelectionMode.One)]

// Use SelectionMode.HighestPriority for plugin systems
[SelectionStrategy(SelectionMode.HighestPriority)]

// Use SelectionMode.All when you need access to all implementations
[SelectionStrategy(SelectionMode.All)]
```

### 5. Keep Interfaces Focused

```csharp
// Good: Focused interface
public interface IPlayerService
{
    int GetLevel();
    void SetLevel(int level);
}

// Avoid: Overly large interfaces (but generator handles them!)
public interface IMassiveService
{
    // 100+ methods...
}
```

## Advanced Topics

### Nullable Reference Types

The generator fully supports nullable reference types:

```csharp
#nullable enable

public interface IDataService
{
    string? GetOptionalData();
    void SetData(string? data);
    Task<string?> LoadAsync();
}

[RealizeService(typeof(IDataService))]
public partial class DataServiceProxy
{
    private readonly IRegistry _registry;
    public DataServiceProxy(IRegistry registry) => _registry = registry;
}

// Generated code preserves all nullable annotations
```

### Inheritance

The generator handles interface inheritance:

```csharp
public interface IBaseService
{
    void BaseMethod();
}

public interface IDerivedService : IBaseService
{
    void DerivedMethod();
}

[RealizeService(typeof(IDerivedService))]
public partial class DerivedServiceProxy
{
    private readonly IRegistry _registry;
    public DerivedServiceProxy(IRegistry registry) => _registry = registry;
}

// Generated code includes both BaseMethod and DerivedMethod
```

### Async/Await

Async methods are properly delegated:

```csharp
public interface IAsyncService
{
    Task InitializeAsync();
    Task<int> CalculateAsync();
    ValueTask DisposeAsync();
}

[RealizeService(typeof(IAsyncService))]
public partial class AsyncServiceProxy
{
    private readonly IRegistry _registry;
    public AsyncServiceProxy(IRegistry registry) => _registry = registry;
}

// Usage:
await proxy.InitializeAsync();
var result = await proxy.CalculateAsync();
```

## FAQ

**Q: Can I add custom logic to the proxy?**
A: Yes! Add your custom methods/properties to the partial class. The generator only adds interface implementations.

**Q: Does the generator support events?**
A: Yes! Events are fully supported with add/remove accessors.

**Q: What about generic interfaces?**
A: Generic methods are supported. Generic interfaces (e.g., `IService<T>`) are not currently supported.

**Q: Can I use this with dependency injection?**
A: Yes! Register your proxy in your DI container and inject `IRegistry`.

**Q: Does this work with .NET Framework?**
A: The generator targets .NET Standard 2.0+. Your project needs .NET Standard 2.0+ or .NET Core/5+/6+/7+/8+.

**Q: How do I debug generated code?**
A: Enable "Generate File" in project properties or use `EmitCompilerGeneratedFiles=true` in your `.csproj`.

**Q: Can I see the generated code?**
A: Yes! Add this to your `.csproj`:

```xml
<PropertyGroup>
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath>Generated</CompilerGeneratedFilesOutputPath>
</PropertyGroup>
```

## Support

For issues, questions, or contributions:

- Check the troubleshooting section above
- Review the examples in this guide
- Check the test project for more examples
- Review the spec document for detailed requirements

---

**Generated by**: Proxy Service Source Generator v1.0.0
**Documentation Version**: 1.0.0
**Last Updated**: 2025-10-22
