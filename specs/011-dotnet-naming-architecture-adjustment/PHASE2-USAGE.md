# SPEC-011 Phase 2: Proxy Service Usage Guide

## Overview

Phase 2 adds generated proxy services that enable Tier-2 DI (Dependency Injection via IRegistry). Consumers can now use strongly-typed proxy classes instead of manually calling `IRegistry.Get<T>()`.

## Architecture

```
┌─────────────────────────────────────────────┐
│  LablabBean.Reporting.Contracts             │
│  ┌────────────────────────────────────────┐ │
│  │  Contracts (Interfaces)                │ │
│  │  - IReportingService                   │ │
│  │  - IReportProvider                     │ │
│  │  - IReportRenderer                     │ │
│  └────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────┐ │
│  │  Proxies (Generated at compile-time)  │ │
│  │  - ReportingServiceProxy               │ │
│  │  - ReportProviderProxy                 │ │
│  │  - ReportRendererProxy                 │ │
│  └────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
           │
           ▼ Uses
    ┌──────────────┐
    │  IRegistry   │  (from LablabBean.Plugins.Contracts)
    └──────────────┘
```

## Usage Patterns

### Pattern 1: Using Proxy Services (Recommended)

```csharp
using LablabBean.Plugins.Contracts;
using LablabBean.Reporting.Contracts.Proxies;
using LablabBean.Reporting.Contracts.Models;

// Instantiate proxy with registry
var reportingService = new ReportingServiceProxy(registry);

// Use as normal service interface
var request = new ReportRequest 
{ 
    Format = ReportFormat.Csv,
    OutputPath = "reports/output.csv"
};

var result = await reportingService.GenerateReportAsync(
    "BuildMetrics", 
    request, 
    cancellationToken
);
```

### Pattern 2: Direct Registry Access (Advanced)

For scenarios requiring custom selection logic (e.g., selecting by name, format):

```csharp
// Get all providers and select by name
var providers = registry.GetAll<IReportProvider>();
var buildMetrics = providers.FirstOrDefault(p => p.Name == "BuildMetrics");

// Get all renderers and select by supported format
var renderers = registry.GetAll<IReportRenderer>();
var csvRenderer = renderers.FirstOrDefault(r => 
    r.SupportedFormats.Contains(ReportFormat.Csv)
);
```

### Pattern 3: Hybrid Approach

Use proxies for main orchestration services, direct registry access for multi-instance services:

```csharp
// Main service via proxy
var reportingService = new ReportingServiceProxy(registry);

// Direct access for format-specific renderer
var allRenderers = registry.GetAll<IReportRenderer>();
var pdfRenderer = allRenderers.FirstOrDefault(r => 
    r.SupportedFormats.Contains(ReportFormat.Pdf)
);
```

## Proxy Details

### ReportingServiceProxy

**Selection Mode**: `HighestPriority`  
**Purpose**: Main reporting orchestration service  
**Usage**: Single instance expected

```csharp
[RealizeService(typeof(IReportingService))]
public partial class ReportingServiceProxy : IReportingService
{
    private readonly IRegistry _registry;
    
    public ReportingServiceProxy(IRegistry registry)
    {
        _registry = registry;
    }
    
    // Implementation generated by ProxyServiceGenerator
    // Delegates to registry.Get<IReportingService>(SelectionMode.HighestPriority)
}
```

### ReportProviderProxy

**Selection Mode**: `HighestPriority`  
**Purpose**: Simple provider access when only one is expected  
**Note**: For multi-provider scenarios, use `registry.GetAll<IReportProvider>()`

```csharp
[RealizeService(typeof(IReportProvider))]
[SelectionStrategy(SelectionMode.HighestPriority)]
public partial class ReportProviderProxy : IReportProvider
```

### ReportRendererProxy

**Selection Mode**: `HighestPriority`  
**Purpose**: Simple renderer access when only one is expected  
**Note**: For format-specific selection, use `registry.GetAll<IReportRenderer>()`

```csharp
[RealizeService(typeof(IReportRenderer))]
[SelectionStrategy(SelectionMode.HighestPriority)]
public partial class ReportRendererProxy : IReportRenderer
```

## Benefits

1. **Type Safety**: Compile-time type checking instead of runtime registry lookups
2. **Cleaner Code**: `new ReportingServiceProxy(registry)` vs `registry.Get<IReportingService>()`
3. **Better IntelliSense**: Full interface discovery in IDEs
4. **Testing**: Easy to mock/substitute implementations
5. **Future-Proof**: Generated code adapts to interface changes

## Source Generation

Proxies are generated at compile-time by `LablabBean.SourceGenerators.Proxy`:

- Input: Partial classes marked with `[RealizeService(typeof(TInterface))]`
- Output: Generated partial class completing the implementation
- Mechanism: Roslyn Incremental Source Generator
- Trigger: Any build of the containing project

To verify generation:

```powershell
# Check generated types in assembly
$dll = "bin/Debug/netstandard2.1/LablabBean.Reporting.Contracts.dll"
[Reflection.Assembly]::LoadFile($dll).GetTypes() | Where-Object { $_.Name -like "*Proxy" }
```

## Testing

Basic proxy tests verify:
1. Constructor requires non-null IRegistry
2. Proxy instances can be created
3. Interface methods delegate to registry

See: `dotnet/tests/LablabBean.Reporting.Contracts.Tests/ProxyTests.cs`

## Next Steps (Phase 3)

Convert reporting renderers to discoverable plugins:
- Move Csv/Html renderers to `dotnet/plugins/`
- Add `plugin.json` manifests
- Update services to discover renderers dynamically

---
**Version**: 1.0.0  
**Created**: 2025-10-22  
**Spec**: `specs/011-dotnet-naming-architecture-adjustment/plan.md`
