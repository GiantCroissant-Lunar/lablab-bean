---
title: Resilience Tiered Architecture
type: architecture-documentation
status: active
created: 2025-10-23
tags: [resilience, architecture, plugins, tiered-pattern]
---

# Resilience Tiered Architecture

## Overview

The Resilience implementation in LablabBean follows the standard tiered service pattern (Tier 1-4), enabling plugin-based extensibility while maintaining type safety and clean separation of concerns.

## Architecture Tiers

### Tier 1: Interface Contract (`IService`)

**Location**: `dotnet/framework/LablabBean.Contracts.Resilience/Services/IService.cs`

The stable, shared contract that all consumers depend on. Defines the resilience service capabilities:

```csharp
public interface IService
{
    // Circuit breaker management
    ICircuitBreaker CreateCircuitBreaker(string operationKey, int failureThreshold, TimeSpan? timeout);
    ICircuitBreaker GetCircuitBreaker(string operationKey);
    bool RemoveCircuitBreaker(string operationKey);

    // Retry policy management
    IRetryPolicy CreateRetryPolicy(int maxAttempts, TimeSpan? baseDelay, TimeSpan? maxDelay);

    // Execution methods
    Task ExecuteWithRetryAsync(Func<Task> operation, IRetryPolicy? retryPolicy, CancellationToken cancellationToken);
    Task<T> ExecuteWithRetryAsync<T>(Func<Task<T>> operation, IRetryPolicy? retryPolicy, CancellationToken cancellationToken);
    Task ExecuteWithResilienceAsync(string operationKey, Func<Task> operation, IRetryPolicy? retryPolicy, CancellationToken cancellationToken);
    Task<T> ExecuteWithResilienceAsync<T>(string operationKey, Func<Task<T>> operation, IRetryPolicy? retryPolicy, CancellationToken cancellationToken);

    // Health & diagnostics
    ResilienceHealthInfo GetHealthStatus();
    ResilienceDebugInfo GetDebugInfo();
    void ResetAllCircuitBreakers();

    // Events
    event Action<string, CircuitBreakerState>? CircuitBreakerStateChanged;
    event Action<string, Exception, int>? OperationRetrying;
    event Action<string>? OperationSucceededAfterRetry;
    event Action<string, Exception>? OperationFailed;
}
```

**Key Points**:

- Lives in the default Assembly Load Context (ALC)
- Shared across host and all plugins
- Never changes location or namespace
- Used by all consumers via dependency injection

### Tier 2: Proxy Service

**Location**: `dotnet/framework/LablabBean.Contracts.Resilience/Services/Proxy/Service.cs`

Delegates all calls to the plugin registry. Generated implementation routes calls to the selected Tier-3 real service.

```csharp
[RealizeService(typeof(IService))]
public partial class Service : IService
{
    private readonly IRegistry _registry;

    public Service(IRegistry registry)
    {
        _registry = registry ?? throw new ArgumentNullException(nameof(registry));
    }

    // Implementation generated by ProxyServiceGenerator source generator
    // Delegates all IService methods to _registry.Resolve<IService>()
}
```

**Behavior**:

- Registered in DI at host startup (before plugins load)
- Does minimal work; delegates to real service from registry
- Registry selection determines which Tier-3 implementation is used
- Transparent to consumers—they only see `IService`

### Tier 3: Real Service Implementation

**Location**: `dotnet/plugins/LablabBean.Plugins.Resilience.Polly/Services/ResilienceService.cs`

The actual resilience engine, loaded by the plugin. This is where Polly v8 pipelines are built and executed.

```csharp
public class ResilienceService : IService, IDisposable
{
    private readonly ILogger _logger;
    private readonly ConcurrentDictionary<string, PollyCircuitBreaker> _circuitBreakers = new();
    private int _totalRetries;
    private int _successfulRetries;
    private int _failedRetries;

    // Full implementation of IService using Polly
    // Manages circuit breakers, retry policies, and resilience pipelines
    // ...
}
```

**Registration** (in `ResiliencePollyPlugin.cs`):

```csharp
public Task InitializeAsync(IPluginContext context, CancellationToken ct = default)
{
    _resilienceService = new ResilienceService(context.Logger);

    context.Registry.Register<IService>(
        _resilienceService,
        new ServiceMetadata
        {
            Priority = 100,
            Name = "ResilienceService",
            Version = "1.0.0"
        }
    );

    context.Logger.LogInformation("Resilience Polly service registered");
    return Task.CompletedTask;
}
```

**Key Points**:

- Lives in the plugin's ALC
- Implements `IService` from Tier 1 (shared contract)
- Registered into the plugin registry with priority
- Can be replaced/supplemented by other plugins providing alternative implementations
- Disposed when plugin stops

### Tier 4: Providers

**Location**: `dotnet/plugins/LablabBean.Plugins.Resilience.Polly/Providers/`

Low-level building blocks that Tier-3 uses to implement resilience patterns.

#### PollyCircuitBreaker

```csharp
public class PollyCircuitBreaker : ICircuitBreaker
{
    // Implements circuit breaker state machine
    // Tracks failures, manages Open/Closed/HalfOpen states
    // Enforces timeout before transitioning from Open to HalfOpen
}
```

#### PollyRetryPolicy

```csharp
public class PollyRetryPolicy : IRetryPolicy
{
    // Defines retry behavior
    // Calculates exponential backoff delays
    // Determines if retry should continue
}
```

**Key Points**:

- Implement shared interfaces (`ICircuitBreaker`, `IRetryPolicy`) from Tier 1
- Specific to the Polly implementation
- Could be replaced/extended in other resilience plugins (e.g., a Hystrix plugin)
- Used internally by Tier-3 service

## Plugin Registry Selection

The proxy service (Tier 2) uses the plugin registry to resolve the active Tier-3 implementation. The registry supports selection modes:

- **First**: Use the first registered implementation
- **HighestPriority**: Use the implementation with the highest priority (default)
- **All**: (Future) Aggregate/compose multiple implementations

For resilience, the standard setup uses **HighestPriority**, allowing plugins to override the default implementation by registering with priority > 100.

## Type Identity & Assembly Load Contexts

```
┌─────────────────────────────────────────────────┐
│ Default ALC (Host)                              │
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │ Tier 1: IService (Contract)             │   │
│  │ Tier 2: Service (Proxy)                 │   │
│  └─────────────────────────────────────────┘   │
│                                                 │
│  DI Container:                                  │
│    services.AddSingleton<IService, Service>()  │
│                                                 │
│  Consumer code:                                 │
│    var svc = sp.GetRequiredService<IService>() │
│    await svc.ExecuteWithRetryAsync(...)        │
│                                                 │
└─────────────────────────────────────────────────┘
                    ↓ delegates via Registry
┌─────────────────────────────────────────────────┐
│ Plugin ALC (Resilience.Polly)                   │
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │ Tier 3: ResilienceService : IService    │   │
│  │ Tier 4: PollyCircuitBreaker             │   │
│  │ Tier 4: PollyRetryPolicy                │   │
│  └─────────────────────────────────────────┘   │
│                                                 │
│  Plugin Initialize:                             │
│    registry.Register<IService>(                 │
│        new ResilienceService(...),              │
│        metadata: { Priority: 100 }              │
│    )                                            │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Why this works**:

- `IService` interface is in the default ALC, shared by both host and plugin
- Plugin creates an instance that implements the **shared** `IService` interface
- Registry stores and returns instances typed as `IService` from the default ALC
- No type identity conflicts; DI resolution works seamlessly

## Benefits of This Architecture

1. **Type Safety**: Interface contract (Tier 1) in default ALC prevents type identity issues
2. **Separation of Concerns**: Proxy (Tier 2) doesn't know about implementation details
3. **Plugin Extensibility**: Real service (Tier 3) can be replaced/extended without changing consumers
4. **Provider Flexibility**: Providers (Tier 4) can be swapped (e.g., different circuit breaker algorithms)
5. **Late Binding**: Service implementation selected at runtime based on plugin availability
6. **Priority Control**: Multiple plugins can offer implementations; registry picks based on priority
7. **Clean Dependencies**: Host only depends on contracts; plugins depend on contracts + implementation libs

## Comparison to Non-Plugin Pattern

For services that **don't** need plugin extensibility, the implementation can be simplified:

```csharp
// Direct registration (no proxy needed)
services.AddSingleton<IService, ResilienceService>();
```

In that case:

- Skip Tier 2 (Proxy)
- Put Tier 3 (Real Service) directly in the host or a shared assembly
- No plugin, no registry, no late binding

The tiered pattern is specifically for services where you want plugin-based extensibility and runtime selection.

## Current Status

✅ **Architecture is correctly implemented**:

- Tier 1 (IService) in `LablabBean.Contracts.Resilience`
- Tier 2 (Proxy) in `LablabBean.Contracts.Resilience.Services.Proxy`
- Tier 3 (ResilienceService) in `LablabBean.Plugins.Resilience.Polly`
- Tier 4 (PollyCircuitBreaker, PollyRetryPolicy) in `LablabBean.Plugins.Resilience.Polly.Providers`

✅ **Plugin registration** uses priority-based selection via `IRegistry`

✅ **Type identity** preserved via shared contract in default ALC

## Future Enhancements

Potential extensions to the resilience implementation:

1. **Multiple Provider Support**: Allow plugins to register policy providers (Tier 4) that Tier 3 discovers and composes
2. **Config-Driven Pipelines**: Load pipeline definitions from config files via a provider
3. **Alternative Implementations**: Add plugins for other resilience frameworks (Hystrix, Refit, etc.)
4. **Composite Mode**: Support "All" selection mode to chain multiple resilience implementations
5. **Telemetry Provider**: Add OpenTelemetry/metrics provider as Tier 4

## Related Documentation

- Plugin System Architecture: `docs/architecture/plugin-system.md` (if exists)
- Proxy Service Generation: `docs/source-generators/proxy-service-generator.md` (if exists)
- Service Registry: `docs/architecture/service-registry.md` (if exists)

---

**Version**: 1.0.0
**Last Updated**: 2025-10-23
**Maintainer**: Architecture Team
