---
doc_id: DOC-2025-00042
title: .NET Project Naming and Architecture Adjustment Specification
doc_type: spec
status: draft
canonical: true
created: 2025-10-22
tags: [architecture, naming, refactoring, plugins, contracts, source-generators]
summary: >
  Comprehensive specification for standardizing .NET project naming conventions,
  implementing proxy service pattern in Contract projects, converting reporting
  renderers to plugins, and establishing platform-agnostic plugin architecture.
source:
  author: agent
  agent: claude
  model: sonnet-4.5
related: [DOC-2025-00018]
---

# .NET Project Naming and Architecture Adjustment Specification

## Executive Summary

This specification defines a comprehensive refactoring plan to:

1. **Standardize naming conventions** across all .NET projects
2. **Implement proxy service pattern** in Contract projects for tier-2 DI abstraction
3. **Convert reporting renderers to plugins** for extensibility
4. **Establish platform-agnostic architecture** for multi-platform support (Unity, .NET)

## Background

### Current State Issues

1. **Inconsistent naming**: Mix of "Abstractions" vs "Contracts" terminology
2. **Source generators not unified**: `Reporting.SourceGen` vs `SourceGenerators.Proxy`
3. **Missing proxy services**: Contract projects contain pure interfaces but lack proxy implementations
4. **Renderers as framework code**: Reporting renderers are framework components instead of plugins
5. **Platform coupling**: Plugin loader tied to .NET-specific `AssemblyLoadContext`

### Architectural Principles

#### Proxy Service Pattern (Tier-2 Abstraction)

```
┌─────────────────────────────────────────────────────────────┐
│ Contract Project (LablabBean.Contracts.Config)              │
├─────────────────────────────────────────────────────────────┤
│ 1. Pure Interface (Tier 1)                                  │
│    public interface IService { string? Get(string key); }   │
│                                                              │
│ 2. Proxy Service (Tier 2 - Generated by SourceGen)          │
│    [RealizeService(typeof(IService))]                       │
│    public partial class ConfigServiceProxy {                │
│        private readonly IRegistry _registry;                │
│        // Generated: Get() delegates to _registry           │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ Plugin Project (LablabBean.Plugins.ConfigManager)           │
├─────────────────────────────────────────────────────────────┤
│ 3. Real Implementation                                      │
│    public class InMemoryConfigService : IService {          │
│        public string? Get(string key) { /* impl */ }        │
│    }                                                         │
│                                                              │
│ 4. Plugin Registration                                      │
│    context.Registry.Register<IService>(                     │
│        new InMemoryConfigService(), metadata);              │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ Consumer (Any code)                                         │
├─────────────────────────────────────────────────────────────┤
│    var proxy = new ConfigServiceProxy(registry);            │
│    var value = proxy.Get("key"); // Resolves to plugin impl │
└─────────────────────────────────────────────────────────────┘
```

**Why Proxy Services?**
- **Decoupling**: Consumer doesn't know about registry
- **Type safety**: Compile-time interface checking
- **Selection strategy**: `[SelectionStrategy(SelectionMode.HighestPriority)]`
- **Cross-ALC support**: Works across plugin isolation boundaries

#### Plugin Architecture Layers

```
┌─────────────────────────────────────────────────────────────┐
│ Contracts Layer (Interfaces + Proxies)                      │
│  - LablabBean.Contracts.{Domain}                            │
│  - LablabBean.Plugins.Contracts                             │
│  - LablabBean.Reporting.Contracts                           │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ Core Framework (Platform-agnostic)                          │
│  - LablabBean.Core, Infrastructure, Reactive                │
│  - LablabBean.Plugins.Core (abstract infrastructure)        │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│ Plugins Layer                                               │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ Gameplay Plugins (Domain implementations)             │  │
│  │  - LablabBean.Plugins.ConfigManager                   │  │
│  │  - LablabBean.Plugins.Inventory                       │  │
│  └───────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │ Infrastructure Plugins (Platform-specific)            │  │
│  │  - LablabBean.Plugins.Loader.ALC (.NET)               │  │
│  │  - LablabBean.Plugins.Loader.HybridCLR (Unity-future) │  │
│  │  - LablabBean.Plugins.Resilience.Polly (.NET)         │  │
│  │  - LablabBean.Plugins.Reporting.Csv                   │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

---

## Naming Convention Standard

### Unified Naming Rules

#### Rule 1: Keep `LablabBean` Prefix

**Rationale:**
- Namespace collision prevention
- NuGet package scoping
- Professional .NET conventions
- Clear ownership identity

**Examples:**
```
✅ LablabBean.Contracts.Config
✅ LablabBean.Plugins.Analytics
❌ Contracts.Config (too generic)
❌ Plugins.Analytics (namespace pollution)
```

#### Rule 2: Use "Contracts" for All Interface Projects

**Rationale:**
- Consistent terminology
- Clear intent (interfaces + proxies)
- Aligns with .NET ecosystem

**Mapping:**
```
Old Name                              → New Name
─────────────────────────────────────────────────────────────
LablabBean.Reporting.Abstractions     → LablabBean.Reporting.Contracts
```

**Keep as "Contracts":**
- `LablabBean.Contracts.{Domain}` (Config, Game, Input, etc.)
- `LablabBean.Plugins.Contracts`

#### Rule 3: Unify Source Generators Under One Namespace

**Rationale:**
- Source generators are development-time tools
- Group by purpose, not by feature
- Matches Microsoft conventions

**Mapping:**
```
Old Name                              → New Name
─────────────────────────────────────────────────────────────
LablabBean.Reporting.SourceGen        → LablabBean.SourceGenerators.Reporting
LablabBean.SourceGenerators.Proxy     → (Keep unchanged)
```

#### Rule 4: Plugin Classification

**Gameplay Plugins** (implement domain contracts):
```
LablabBean.Plugins.{Feature}
  - LablabBean.Plugins.ConfigManager
  - LablabBean.Plugins.Inventory
  - LablabBean.Plugins.Analytics
```

**Infrastructure Plugins** (platform-specific or cross-cutting):
```
LablabBean.Plugins.{Category}.{Implementation}
  - LablabBean.Plugins.Loader.ALC
  - LablabBean.Plugins.Reporting.Csv
  - LablabBean.Plugins.Resilience.Polly
```

---

## Phase 1: Simple Renames (Low Risk)

### Task 1.1: Rename Reporting.Abstractions → Reporting.Contracts

**Actions:**
1. Rename directory:
   ```
   dotnet/framework/LablabBean.Reporting.Abstractions/
   → dotnet/framework/LablabBean.Reporting.Contracts/
   ```

2. Rename .csproj file:
   ```
   LablabBean.Reporting.Abstractions.csproj
   → LablabBean.Reporting.Contracts.csproj
   ```

3. Update namespace in all .cs files:
   ```csharp
   // Old
   namespace LablabBean.Reporting.Abstractions.Contracts;

   // New
   namespace LablabBean.Reporting.Contracts;
   ```

4. Update all project references:
   ```xml
   <!-- Old -->
   <ProjectReference Include="..\LablabBean.Reporting.Abstractions\..." />

   <!-- New -->
   <ProjectReference Include="..\LablabBean.Reporting.Contracts\..." />
   ```

5. Update all using statements across codebase:
   ```csharp
   // Old
   using LablabBean.Reporting.Abstractions.Models;
   using LablabBean.Reporting.Abstractions.Contracts;

   // New
   using LablabBean.Reporting.Contracts.Models;
   using LablabBean.Reporting.Contracts;
   ```

6. Update solution file (LablabBean.sln)

**Affected Projects:**
- `LablabBean.Reporting.Renderers.Csv`
- `LablabBean.Reporting.Renderers.Html`
- `LablabBean.Reporting.Analytics`
- `LablabBean.Reporting.Providers.Build`
- All reporting test projects

**Verification:**
```bash
dotnet build dotnet/LablabBean.sln
dotnet test dotnet/LablabBean.sln
```

---

### Task 1.2: Rename Reporting.SourceGen → SourceGenerators.Reporting

**Actions:**
1. Rename directory:
   ```
   dotnet/framework/LablabBean.Reporting.SourceGen/
   → dotnet/framework/LablabBean.SourceGenerators.Reporting/
   ```

2. Rename .csproj file

3. Update namespace:
   ```csharp
   // Old
   namespace LablabBean.Reporting.SourceGen;

   // New
   namespace LablabBean.SourceGenerators.Reporting;
   ```

4. Update all project references that use this as analyzer:
   ```xml
   <!-- Old -->
   <ProjectReference Include="..\LablabBean.Reporting.SourceGen\..."
                     OutputItemType="Analyzer"
                     ReferenceOutputAssembly="false" />

   <!-- New -->
   <ProjectReference Include="..\LablabBean.SourceGenerators.Reporting\..."
                     OutputItemType="Analyzer"
                     ReferenceOutputAssembly="false" />
   ```

**Affected Projects:**
- `LablabBean.Reporting.Analytics`
- `LablabBean.Reporting.Providers.Build`

**Verification:**
```bash
dotnet build dotnet/LablabBean.sln
# Verify source generation still works
dotnet build dotnet/framework/LablabBean.Reporting.Analytics/ -v detailed
```

---

## Phase 2: Add Proxy Services to Contract Projects

### Task 2.1: Audit Existing Contract Projects

**Check each Contract project for:**
1. ✅ Has ProjectReference to `LablabBean.SourceGenerators.Proxy` with `OutputItemType="Analyzer"`
2. ✅ Contains proxy partial classes with `[RealizeService]` attribute
3. ✅ Proxy classes have `private readonly IRegistry _registry` field

**Projects to audit:**
- `LablabBean.Contracts.Config`
- `LablabBean.Contracts.Game`
- `LablabBean.Contracts.Input`
- `LablabBean.Contracts.Resource`
- `LablabBean.Contracts.Scene`
- `LablabBean.Contracts.UI`

### Task 2.2: Add Missing Proxy Services

**For each interface in Contract projects:**

1. **Create proxy service class:**
   ```csharp
   // In LablabBean.Contracts.Config/Services/ConfigServiceProxy.cs
   using LablabBean.Plugins.Contracts;
   using LablabBean.Plugins.Contracts.Attributes;

   namespace LablabBean.Contracts.Config.Services;

   /// <summary>
   /// Proxy service for IService - delegates to registry.
   /// </summary>
   [RealizeService(typeof(IService))]
   [SelectionStrategy(SelectionMode.HighestPriority)]
   public partial class ConfigServiceProxy
   {
       private readonly IRegistry _registry;

       public ConfigServiceProxy(IRegistry registry)
       {
           _registry = registry ?? throw new ArgumentNullException(nameof(registry));
       }
   }
   ```

2. **Add source generator reference to .csproj:**
   ```xml
   <ItemGroup>
     <ProjectReference Include="..\LablabBean.Plugins.Contracts\..." />
     <ProjectReference Include="..\LablabBean.SourceGenerators.Proxy\..."
                       OutputItemType="Analyzer"
                       ReferenceOutputAssembly="false" />
   </ItemGroup>
   ```

3. **Verify generation:**
   ```bash
   dotnet build -v detailed
   # Check obj/Debug/net8.0/generated/ for generated code
   ```

### Task 2.3: Update Documentation

Create usage guide showing how to use proxy services:

```markdown
## Using Contract Proxies

### Consumer Side (recommended)
```csharp
var configProxy = new ConfigServiceProxy(registry);
var value = configProxy.Get("game:difficulty");
```

### Direct Registry Access (advanced)
```csharp
var service = registry.Get<IService>(SelectionMode.HighestPriority);
var value = service.Get("game:difficulty");
```
```

---

## Phase 3: Convert Reporting Renderers to Plugins

### Task 3.1: Move Csv Renderer to Plugin

**Source:** `dotnet/framework/LablabBean.Reporting.Renderers.Csv/`
**Destination:** `dotnet/plugins/LablabBean.Plugins.Reporting.Csv/`

**Actions:**

1. **Create new plugin structure:**
   ```
   dotnet/plugins/LablabBean.Plugins.Reporting.Csv/
   ├── CsvReportingPlugin.cs          (NEW - IPlugin implementation)
   ├── CsvReportRenderer.cs           (MOVED - existing renderer)
   └── LablabBean.Plugins.Reporting.Csv.csproj (UPDATED)
   ```

2. **Create plugin class:**
   ```csharp
   using LablabBean.Plugins.Contracts;
   using LablabBean.Reporting.Contracts;
   using Microsoft.Extensions.Logging;

   namespace LablabBean.Plugins.Reporting.Csv;

   /// <summary>
   /// Plugin providing CSV report rendering capability.
   /// </summary>
   public class CsvReportingPlugin : IPlugin
   {
       public string Id => "lablab-bean.reporting.csv";
       public string Name => "CSV Report Renderer";
       public string Version => "1.0.0";

       public Task InitializeAsync(IPluginContext context, CancellationToken ct = default)
       {
           context.Logger.LogInformation("Initializing CSV reporting plugin...");

           var renderer = new CsvReportRenderer(context.Logger);
           context.Registry.Register<IReportRenderer>(
               renderer,
               new ServiceMetadata
               {
                   Priority = 100,
                   Name = "Csv",
                   Version = "1.0.0"
               }
           );

           context.Logger.LogInformation("CSV renderer registered");
           return Task.CompletedTask;
       }

       public Task StartAsync(CancellationToken ct = default)
       {
           return Task.CompletedTask;
       }

       public Task StopAsync(CancellationToken ct = default)
       {
           return Task.CompletedTask;
       }
   }
   ```

3. **Update .csproj:**
   ```xml
   <Project Sdk="Microsoft.NET.Sdk">
     <PropertyGroup>
       <TargetFramework>net8.0</TargetFramework>
       <ImplicitUsings>enable</ImplicitUsings>
       <Nullable>enable</Nullable>
     </PropertyGroup>

     <ItemGroup>
       <ProjectReference Include="..\..\framework\LablabBean.Plugins.Contracts\..." />
       <ProjectReference Include="..\..\framework\LablabBean.Reporting.Contracts\..." />
     </ItemGroup>

     <ItemGroup>
       <PackageReference Include="CsvHelper" />
       <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
     </ItemGroup>
   </Project>
   ```

4. **Update namespace in CsvReportRenderer.cs:**
   ```csharp
   // Old
   namespace LablabBean.Reporting.Renderers.Csv;

   // New
   namespace LablabBean.Plugins.Reporting.Csv;
   ```

5. **Create plugin manifest:**
   ```json
   // plugin.json
   {
     "id": "lablab-bean.reporting.csv",
     "name": "CSV Report Renderer",
     "version": "1.0.0",
     "author": "Lablab Bean Team",
     "description": "Renders reports to CSV format using CsvHelper",
     "entryPoint": "LablabBean.Plugins.Reporting.Csv.CsvReportingPlugin",
     "dependencies": [],
     "capabilities": ["reporting", "csv-export"]
   }
   ```

6. **Update all references** across codebase

7. **Update tests:**
   - Move test project to `dotnet/tests/LablabBean.Plugins.Reporting.Csv.Tests/`
   - Update namespaces
   - Add plugin lifecycle tests

### Task 3.2: Move Html Renderer to Plugin

**Repeat Task 3.1 steps for Html renderer:**
- Source: `dotnet/framework/LablabBean.Reporting.Renderers.Html/`
- Destination: `dotnet/plugins/LablabBean.Plugins.Reporting.Html/`
- Plugin ID: `lablab-bean.reporting.html`

### Task 3.3: Update IReportingService to Discover Renderers

**Current (hardcoded):**
```csharp
// Somewhere in ReportingService initialization
var csvRenderer = new CsvReportRenderer(logger);
var htmlRenderer = new HtmlReportRenderer(logger);
```

**New (dynamic discovery via registry):**
```csharp
public class ReportingService : IReportingService
{
    private readonly IRegistry _registry;

    public async Task<ReportResult> GenerateReportAsync(
        string providerName,
        ReportRequest request,
        CancellationToken ct)
    {
        // Get all renderers from registry
        var renderers = _registry.GetAll<IReportRenderer>();

        // Find renderer supporting requested format
        var renderer = renderers.FirstOrDefault(r =>
            r.SupportedFormats.Contains(request.Format));

        if (renderer == null)
            throw new InvalidOperationException(
                $"No renderer found for format: {request.Format}");

        // ... rest of implementation
    }
}
```

---

## Phase 4: Platform-Agnostic Plugin Architecture (Future)

### Task 4.1: Extract Plugin Loader to Platform-Specific Plugins

**Goal:** Separate `AssemblyLoadContext`-based loader from core plugin infrastructure.

**Current structure:**
```
LablabBean.Plugins.Core/
├── PluginLoader.cs              (Uses ALC - .NET specific)
├── Registry.cs                  (Platform-agnostic)
├── EventBus.cs                  (Platform-agnostic)
└── PluginHost.cs                (Platform-agnostic)
```

**Proposed structure:**
```
LablabBean.Plugins.Core/
├── Registry.cs                  (Platform-agnostic)
├── EventBus.cs                  (Platform-agnostic)
├── PluginHost.cs                (Platform-agnostic)
└── IPluginLoader.cs             (NEW - abstraction)

LablabBean.Plugins.Loader.ALC/   (NEW - .NET implementation)
├── AlcPluginLoader.cs           (Implements IPluginLoader)
└── AlcPluginContext.cs

LablabBean.Plugins.Loader.HybridCLR/ (FUTURE - Unity implementation)
├── HybridClrPluginLoader.cs     (Implements IPluginLoader)
└── HybridClrPluginContext.cs
```

**Benefits:**
- Unity support via HybridCLR
- Testability (mock loader)
- Clear platform boundaries

### Task 4.2: Define Resilience Abstraction Layer

**Structure:**
```
LablabBean.Resilience.Contracts/
├── ICircuitBreaker.cs
├── IRetryPolicy.cs
├── ITimeout.cs
└── ResilienceProxy.cs           (Generated)

LablabBean.Plugins.Resilience.Polly/
├── PollyCircuitBreaker.cs
├── PollyRetryPolicy.cs
└── ResiliencePlugin.cs
```

**Usage:**
```csharp
// Consumer code (platform-agnostic)
var resilienceProxy = new ResilienceProxy(registry);
await resilienceProxy.ExecuteAsync(async () => {
    // risky operation
});

// Plugin registers Polly implementation
context.Registry.Register<IRetryPolicy>(
    new PollyRetryPolicy(maxRetries: 3));
```

---

## Implementation Checklist

### Phase 1: Simple Renames
- [ ] Rename `Reporting.Abstractions` → `Reporting.Contracts`
- [ ] Update all references and usings
- [ ] Rename `Reporting.SourceGen` → `SourceGenerators.Reporting`
- [ ] Update analyzer references
- [ ] Verify builds and tests pass
- [ ] Update documentation

### Phase 2: Proxy Services
- [ ] Audit all Contract projects
- [ ] Add `SourceGenerators.Proxy` reference to each
- [ ] Create proxy classes for each interface
- [ ] Verify source generation works
- [ ] Add proxy usage documentation
- [ ] Update examples and test harnesses

### Phase 3: Renderer Plugins
- [ ] Move `Reporting.Renderers.Csv` → `Plugins.Reporting.Csv`
- [ ] Create `CsvReportingPlugin` with `IPlugin`
- [ ] Add plugin manifest
- [ ] Move `Reporting.Renderers.Html` → `Plugins.Reporting.Html`
- [ ] Create `HtmlReportingPlugin`
- [ ] Update `IReportingService` for dynamic discovery
- [ ] Update all test projects
- [ ] Verify plugin loading works
- [ ] Update integration tests
- [ ] Document renderer plugin development

### Phase 4: Platform Abstraction (Future)
- [ ] Define `IPluginLoader` interface
- [ ] Extract `AlcPluginLoader` to separate project
- [ ] Define resilience contracts
- [ ] Create Polly plugin implementation
- [ ] Document platform extension points

---

## Testing Strategy

### Unit Tests
- All renamed projects must pass existing tests
- Add tests for new proxy services
- Add plugin lifecycle tests for renderers

### Integration Tests
- Verify renderer plugins load correctly
- Test dynamic renderer discovery
- End-to-end report generation with plugin renderers

### Regression Tests
- Ensure all existing functionality works after renames
- Verify backward compatibility where needed

---

## Migration Guide for Other Agents

### For Automated Refactoring Tools

1. **Use git mv for renames** to preserve history
2. **Find and replace namespaces** in this order:
   - `LablabBean.Reporting.Abstractions.Contracts` → `LablabBean.Reporting.Contracts`
   - `LablabBean.Reporting.Abstractions.Models` → `LablabBean.Reporting.Contracts.Models`
   - `LablabBean.Reporting.Abstractions` → `LablabBean.Reporting.Contracts`
   - `LablabBean.Reporting.SourceGen` → `LablabBean.SourceGenerators.Reporting`
   - `LablabBean.Reporting.Renderers.Csv` → `LablabBean.Plugins.Reporting.Csv`
   - `LablabBean.Reporting.Renderers.Html` → `LablabBean.Plugins.Reporting.Html`

3. **Update project references** in .csproj files
4. **Update solution file** with new paths
5. **Run build verification** after each phase

### For Manual Implementation

See detailed task breakdowns in each phase section above.

---

## Rollback Plan

If issues arise during Phase 3 (renderer plugins):

1. **Keep old renderer projects** in `dotnet/framework.bak/` until Phase 3 complete
2. **Feature flag** for plugin-based vs framework renderers
3. **Revert commits** in reverse order (Phase 3 → Phase 2 → Phase 1)

---

## References

- **Proxy Service Generator**: `dotnet/framework/LablabBean.SourceGenerators.Proxy/`
- **Plugin System Docs**: `docs/_inbox/2025-10-21-plugin-system-overview--DOC-2025-00040.md`
- **Architecture Overview**: `docs/ARCHITECTURE.md` (DOC-2025-00018)

---

## Approval and Timeline

**Recommended Implementation Order:**
1. Phase 1 (Renames): 1-2 days
2. Phase 2 (Proxy Services): 2-3 days
3. Phase 3 (Renderer Plugins): 3-5 days
4. Phase 4 (Platform Abstraction): Future milestone

**Total Estimated Effort:** 1-2 weeks for Phases 1-3

---

## Appendix: Complete Project Structure (After Refactoring)

```
dotnet/
├── framework/
│   ├── LablabBean.Core
│   ├── LablabBean.Infrastructure
│   ├── LablabBean.Reactive
│   ├── LablabBean.Game.Core
│   │
│   ├── Contracts (Interfaces + Proxies)
│   ├── LablabBean.Contracts.Config
│   ├── LablabBean.Contracts.Game
│   ├── LablabBean.Contracts.Input
│   ├── LablabBean.Contracts.Resource
│   ├── LablabBean.Contracts.Scene
│   ├── LablabBean.Contracts.UI
│   ├── LablabBean.Plugins.Contracts
│   ├── LablabBean.Reporting.Contracts        ← Renamed
│   │
│   ├── Source Generators
│   ├── LablabBean.SourceGenerators.Proxy
│   ├── LablabBean.SourceGenerators.Reporting ← Renamed
│   │
│   ├── Plugin Infrastructure
│   ├── LablabBean.Plugins.Core
│   │
│   └── Reporting Core
│       ├── LablabBean.Reporting.Analytics
│       └── LablabBean.Reporting.Providers.Build
│
├── plugins/
│   ├── Gameplay Plugins
│   ├── LablabBean.Plugins.Analytics
│   ├── LablabBean.Plugins.ConfigManager
│   ├── LablabBean.Plugins.InputHandler
│   ├── LablabBean.Plugins.Inventory
│   ├── LablabBean.Plugins.MockGame
│   ├── LablabBean.Plugins.ReactiveUI
│   ├── LablabBean.Plugins.ResourceLoader
│   ├── LablabBean.Plugins.SceneLoader
│   ├── LablabBean.Plugins.StatusEffects
│   │
│   └── Infrastructure Plugins
│       ├── LablabBean.Plugins.Reporting.Csv   ← Moved from framework
│       └── LablabBean.Plugins.Reporting.Html  ← Moved from framework
│
├── tests/
│   ├── LablabBean.Contracts.*.Tests
│   ├── LablabBean.Plugins.*.Tests
│   ├── LablabBean.Plugins.Reporting.Csv.Tests   ← Moved
│   ├── LablabBean.Plugins.Reporting.Html.Tests  ← Moved
│   └── LablabBean.Reporting.*.Tests
│
├── console-app/
├── windows-app/
└── examples/
```

---

**Document Status:** Draft - Ready for review and implementation
**Next Steps:** Submit for architecture review, then proceed with Phase 1
