using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace LablabBean.SourceGenerators.Proxy;

/// <summary>
/// Generates DI extension methods for proxy service registration.
/// Scans for [RealizeService] attributes and creates AddXxxProxy() methods.
/// </summary>
[Generator]
public class DIExtensionsGenerator : IIncrementalGenerator
{
    private const string RealizeServiceAttributeName = "LablabBean.Plugins.Contracts.Attributes.RealizeServiceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [RealizeService] attribute
        var proxyClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateClass(node),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(proxyClasses.Collect());

        // Generate DI extension methods
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDeclaration)
            return false;

        if (classDeclaration.AttributeLists.Count == 0)
            return false;

        if (!classDeclaration.Modifiers.Any(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword))
            return false;

        return true;
    }

    private static ProxyClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (classSymbol is null)
            return null;

        // Check for [RealizeService] attribute
        var realizeServiceAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == RealizeServiceAttributeName);

        if (realizeServiceAttribute is null)
            return null;

        // Get service interface type
        ITypeSymbol? serviceType = null;
        if (realizeServiceAttribute.ConstructorArguments.Length > 0)
        {
            var typeArg = realizeServiceAttribute.ConstructorArguments[0];
            if (typeArg.Kind == TypedConstantKind.Type)
            {
                serviceType = typeArg.Value as ITypeSymbol;
            }
        }

        if (serviceType is null)
            return null;

        return new ProxyClassInfo
        {
            ProxyClassName = classSymbol.Name,
            ProxyNamespace = classSymbol.ContainingNamespace.ToDisplayString(),
            ServiceInterfaceFullName = serviceType.ToDisplayString(),
            ServiceInterfaceShortName = serviceType.Name
        };
    }

    private static void Execute(Compilation compilation, ImmutableArray<ProxyClassInfo> proxyClasses, SourceProductionContext context)
    {
        if (proxyClasses.IsDefaultOrEmpty)
            return;

        // Group by namespace to generate one extension class per namespace
        var groupedByNamespace = proxyClasses.GroupBy(p => GetRootNamespace(p.ProxyNamespace));

        foreach (var group in groupedByNamespace)
        {
            var rootNamespace = group.Key;
            var source = GenerateDIExtensions(rootNamespace, group.ToList());
            context.AddSource($"{rootNamespace}.Extensions.ServiceCollectionExtensions.g.cs", source);
        }
    }

    private static string GetRootNamespace(string fullNamespace)
    {
        // Extract root namespace (e.g., "LablabBean.Contracts.Resilience" from "LablabBean.Contracts.Resilience.Services.Proxy")
        var parts = fullNamespace.Split('.');
        if (parts.Length >= 3)
            return string.Join(".", parts.Take(3));
        return fullNamespace;
    }

    private static string GenerateDIExtensions(string rootNamespace, List<ProxyClassInfo> proxyClasses)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// Generated by DIExtensionsGenerator");
        sb.AppendLine("// This file provides DI registration extension methods for proxy services.");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Usings
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using LablabBean.Plugins.Contracts;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {rootNamespace}.Extensions;");
        sb.AppendLine();

        // Class
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Extension methods for registering {rootNamespace} proxy services.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class ServiceCollectionExtensions");
        sb.AppendLine("{");

        // Generate a method for each proxy class
        foreach (var proxyClass in proxyClasses)
        {
            GenerateAddProxyMethod(sb, proxyClass);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateAddProxyMethod(StringBuilder sb, ProxyClassInfo proxyClass)
    {
        // Extract service name from interface (e.g., IService -> Service)
        var serviceName = proxyClass.ServiceInterfaceShortName.TrimStart('I');
        
        // Extract domain from namespace (e.g., LablabBean.Contracts.Resilience -> Resilience)
        var namespaceParts = proxyClass.ProxyNamespace.Split('.');
        var domain = namespaceParts.Length >= 3 ? namespaceParts[2] : "";
        
        // Generate method name: Add{Domain}{Service}Proxy (e.g., AddResilienceServiceProxy)
        var methodName = $"Add{domain}{serviceName}Proxy";

        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Registers the {proxyClass.ServiceInterfaceShortName} proxy that delegates to the plugin registry.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"services\">The service collection.</param>");
        sb.AppendLine("    /// <param name=\"mode\">Service selection mode when multiple implementations exist. Default: HighestPriority.</param>");
        sb.AppendLine("    /// <returns>The service collection for chaining.</returns>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine("    /// The proxy will resolve the actual implementation from the plugin registry at runtime.");
        sb.AppendLine("    /// Ensure AddPluginSystem() is called before this method to register the IRegistry.");
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine($"    public static IServiceCollection {methodName}(");
        sb.AppendLine("        this IServiceCollection services,");
        sb.AppendLine("        SelectionMode mode = SelectionMode.HighestPriority)");
        sb.AppendLine("    {");
        sb.AppendLine($"        services.AddSingleton<{proxyClass.ServiceInterfaceFullName}>(sp =>");
        sb.AppendLine("        {");
        sb.AppendLine("            var registry = sp.GetRequiredService<IRegistry>();");
        sb.AppendLine($"            return new {proxyClass.ProxyNamespace}.{proxyClass.ProxyClassName}(registry);");
        sb.AppendLine("        });");
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
    }

    private class ProxyClassInfo
    {
        public string ProxyClassName { get; set; } = null!;
        public string ProxyNamespace { get; set; } = null!;
        public string ServiceInterfaceFullName { get; set; } = null!;
        public string ServiceInterfaceShortName { get; set; } = null!;
    }
}
